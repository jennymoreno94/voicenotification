# üèóÔ∏è Arquitectura de la Librer√≠a

## Visi√≥n General

Esta librer√≠a implementa **Clean Architecture** con separaci√≥n clara de responsabilidades y principios SOLID.

## üìê Capas de la Arquitectura

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    PRESENTATION                          ‚îÇ
‚îÇ  (VoiceNotificationManager, Workers, UI Components)     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      DOMAIN                              ‚îÇ
‚îÇ     (Use Cases, Models, Repository Interfaces)          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                       DATA                               ‚îÇ
‚îÇ  (Repository Implementations, TTS, Factories)            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üéØ Capa de Dominio (Domain Layer)

### Responsabilidad
Contiene la l√≥gica de negocio pura, independiente de frameworks y tecnolog√≠as.

### Componentes

#### 1. Models
```java
// NotificationType.java
public enum NotificationType {
    SPEED_EXCESS,
    HARSH_BRAKING,
    HARSH_ACCELERATION,
    SHARP_TURN,
    CUSTOM
}
```

**Caracter√≠sticas:**
- Inmutables
- Sin dependencias de Android
- Validaci√≥n en construcci√≥n
- Builder pattern para flexibilidad

#### 2. Repository Interfaces
```java
public interface VoiceNotificationRepository {
    void speak(VoiceNotification notification);
    void stop();
    boolean isSpeaking();
    void configure(VoiceConfig config);
    boolean isAvailable();
    void shutdown();
}
```

**Principios:**
- Dependency Inversion (SOLID)
- Abstracci√≥n de implementaci√≥n
- Testeable con mocks

#### 3. Use Cases
```java
public class SpeakNotificationUseCase {
    private final VoiceNotificationRepository repository;
    
    public void execute(VoiceNotification notification) {
        // L√≥gica de negocio
        if (notification.getPriority().getLevel() >= HIGH) {
            repository.stop(); // Interrumpir si es alta prioridad
        }
        repository.speak(notification);
    }
}
```

**Ventajas:**
- L√≥gica de negocio encapsulada
- Reutilizable
- F√°cil de testear
- Single Responsibility

## üíæ Capa de Datos (Data Layer)

### Responsabilidad
Implementa las interfaces del dominio usando tecnolog√≠as espec√≠ficas.

### Componentes

#### 1. Repository Implementation
```java
public class VoiceNotificationRepositoryImpl 
    implements VoiceNotificationRepository {
    
    private TextToSpeech textToSpeech;
    
    @Override
    public void speak(VoiceNotification notification) {
        // Implementaci√≥n con Android TTS
        textToSpeech.speak(
            notification.getMessage(),
            queueMode,
            params
        );
    }
}
```

**Caracter√≠sticas:**
- Implementa interfaces del dominio
- Maneja detalles t√©cnicos (TTS)
- Gesti√≥n de recursos
- Callbacks y listeners

#### 2. Factories
```java
public class NotificationMessageFactory {
    public static String getMessage(
        NotificationType type, 
        Locale locale
    ) {
        // L√≥gica de creaci√≥n de mensajes
    }
}
```

**Prop√≥sito:**
- Creaci√≥n de objetos complejos
- Mensajes predefinidos
- Internacionalizaci√≥n

## üé® Capa de Presentaci√≥n (Presentation Layer)

### Responsabilidad
Expone la funcionalidad a los consumidores de la librer√≠a.

### Componentes

#### 1. Manager (Facade Pattern)
```java
public class VoiceNotificationManager 
    implements DefaultLifecycleObserver {
    
    private final SpeakNotificationUseCase speakUseCase;
    private final MutableLiveData<NotificationEvent> eventLiveData;
    
    public void speak(VoiceNotification notification) {
        speakUseCase.execute(notification);
    }
    
    public LiveData<NotificationEvent> getEvents() {
        return eventLiveData;
    }
}
```

**Caracter√≠sticas:**
- Singleton thread-safe
- Lifecycle-aware
- API simple y clara
- Observable events (LiveData)

#### 2. Workers
```java
public class VoiceNotificationWorker extends Worker {
    @Override
    public Result doWork() {
        // Procesar notificaciones en background
        return Result.success();
    }
}
```

**Prop√≥sito:**
- Notificaciones en background
- Garant√≠a de entrega
- Programaci√≥n diferida

## üîß Capa de Utilidades (Utils)

### Componentes Auxiliares

#### 1. NotificationThrottler
```java
public class NotificationThrottler {
    private Map<NotificationType, Long> lastNotificationTime;
    
    public boolean tryNotify(NotificationType type) {
        // L√≥gica de cooldown
    }
}
```

**Prop√≥sito:** Prevenir spam de notificaciones

#### 2. DriverBehaviorAnalyzer
```java
public class DriverBehaviorAnalyzer {
    public boolean isSpeedExcess(int current, int limit);
    public boolean isHarshBraking(float acceleration);
    public NotificationType analyzeAcceleration(...);
}
```

**Prop√≥sito:** An√°lisis de datos de conducci√≥n

#### 3. VoiceNotificationScheduler
```java
public class VoiceNotificationScheduler {
    private WorkManager workManager;
    
    public void scheduleNotification(
        VoiceNotification notification, 
        long delayMillis
    );
}
```

**Prop√≥sito:** Programaci√≥n de notificaciones

## üîÑ Flujo de Datos

### Flujo Normal
```
Usuario ‚Üí Manager ‚Üí UseCase ‚Üí Repository ‚Üí TTS
                                    ‚Üì
                              LiveData Event
                                    ‚Üì
                              Observer (UI)
```

### Flujo con Throttling
```
Sensor Data ‚Üí Analyzer ‚Üí Throttler ‚Üí Manager ‚Üí UseCase
                            ‚Üì
                        (blocked)
                            ‚Üì
                        No Action
```

### Flujo Programado
```
Scheduler ‚Üí WorkManager ‚Üí Worker ‚Üí Manager ‚Üí UseCase
                                                ‚Üì
                                          Repository
```

## üéØ Patrones de Dise√±o Implementados

### 1. Repository Pattern
**Ubicaci√≥n:** `domain/repository/` y `data/repository/`

**Beneficio:** Abstracci√≥n de la fuente de datos

### 2. Use Case Pattern
**Ubicaci√≥n:** `domain/usecase/`

**Beneficio:** Encapsulaci√≥n de l√≥gica de negocio

### 3. Builder Pattern
**Ubicaci√≥n:** `VoiceNotification`, `VoiceConfig`

**Beneficio:** Construcci√≥n flexible de objetos

### 4. Singleton Pattern
**Ubicaci√≥n:** `VoiceNotificationManager`

**Beneficio:** Instancia √∫nica, thread-safe

### 5. Observer Pattern
**Ubicaci√≥n:** `LiveData` en Manager

**Beneficio:** Notificaci√≥n reactiva de eventos

### 6. Factory Pattern
**Ubicaci√≥n:** `NotificationMessageFactory`

**Beneficio:** Creaci√≥n centralizada de mensajes

### 7. Facade Pattern
**Ubicaci√≥n:** `VoiceNotificationManager`

**Beneficio:** API simple sobre sistema complejo

### 8. Strategy Pattern
**Ubicaci√≥n:** `DriverBehaviorAnalyzer`

**Beneficio:** Algoritmos intercambiables

## üìã Principios SOLID

### Single Responsibility
- Cada clase tiene una √∫nica responsabilidad
- `SpeakNotificationUseCase` solo maneja la l√≥gica de hablar
- `NotificationThrottler` solo maneja cooldowns

### Open/Closed
- Extensible mediante herencia e interfaces
- Cerrado a modificaci√≥n de c√≥digo existente
- Nuevos tipos de notificaciones sin cambiar c√≥digo

### Liskov Substitution
- Implementaciones de `VoiceNotificationRepository` son intercambiables
- Mocks en tests sustituyen implementaciones reales

### Interface Segregation
- Interfaces espec√≠ficas y peque√±as
- `VoiceNotificationRepository` solo m√©todos necesarios
- No interfaces "gordas"

### Dependency Inversion
- Dependencias apuntan hacia abstracciones
- Use Cases dependen de interfaces, no implementaciones
- Inyecci√≥n de dependencias en constructores

## üß™ Testabilidad

### Unit Tests
```java
@Test
public void testSpeakUseCase() {
    // Mock del repository
    VoiceNotificationRepository mockRepo = mock(...);
    
    // Use case con mock
    SpeakNotificationUseCase useCase = 
        new SpeakNotificationUseCase(mockRepo);
    
    // Test
    useCase.execute(notification);
    verify(mockRepo).speak(notification);
}
```

### Integration Tests
```java
@Test
public void testManagerIntegration() {
    VoiceNotificationManager manager = 
        VoiceNotificationManager.getInstance(context);
    
    manager.speak(NotificationType.SPEED_EXCESS);
    assertTrue(manager.isSpeaking());
}
```

## üîê Thread Safety

### Singleton Thread-Safe
```java
public static VoiceNotificationManager getInstance(Context context) {
    if (instance == null) {
        synchronized (VoiceNotificationManager.class) {
            if (instance == null) {
                instance = new VoiceNotificationManager(context);
            }
        }
    }
    return instance;
}
```

**Patr√≥n:** Double-checked locking

### LiveData Thread-Safe
```java
eventLiveData.postValue(event); // Thread-safe
```

**Beneficio:** Actualizaci√≥n desde cualquier thread

## üìä Gesti√≥n de Recursos

### Lifecycle Management
```java
@Override
public void onDestroy(LifecycleOwner owner) {
    repository.shutdown();
    owner.getLifecycle().removeObserver(this);
}
```

**Previene:** Memory leaks

### TTS Resource Management
```java
@Override
public void shutdown() {
    if (textToSpeech != null) {
        textToSpeech.stop();
        textToSpeech.shutdown();
    }
}
```

**Libera:** Recursos del sistema

## üöÄ Extensibilidad

### Agregar Nuevo Tipo de Notificaci√≥n
```java
// 1. Agregar en enum
public enum NotificationType {
    // ...
    DROWSINESS_DETECTED  // Nuevo
}

// 2. Agregar mensaje en factory
SPANISH_MESSAGES.put(
    NotificationType.DROWSINESS_DETECTED,
    "Detectada somnolencia. Tome un descanso."
);

// 3. Usar normalmente
voiceManager.speak(NotificationType.DROWSINESS_DETECTED);
```

### Agregar Nueva Fuente de Datos
```java
// 1. Implementar interface
public class CloudTTSRepository 
    implements VoiceNotificationRepository {
    // Implementaci√≥n con Google Cloud TTS
}

// 2. Inyectar en use case
SpeakNotificationUseCase useCase = 
    new SpeakNotificationUseCase(new CloudTTSRepository());
```

## üìà Escalabilidad

### Horizontal
- M√∫ltiples instancias en diferentes procesos
- WorkManager distribuye carga

### Vertical
- Optimizado para bajo consumo de recursos
- Lazy initialization
- Resource pooling

## üîç Monitoreo y Debugging

### Logging Strategy
```java
private static final String TAG = "VoiceNotificationRepo";
Log.d(TAG, "Speaking notification: " + message);
```

### Event Tracking
```java
voiceManager.getEvents().observe(this, event -> {
    analytics.logEvent("voice_notification", bundle);
});
```

## üí° Mejores Pr√°cticas Implementadas

1. ‚úÖ **Inmutabilidad** - Modelos inmutables
2. ‚úÖ **Null Safety** - Anotaciones `@NonNull`/`@Nullable`
3. ‚úÖ **Resource Management** - Lifecycle-aware
4. ‚úÖ **Error Handling** - Try-catch y callbacks
5. ‚úÖ **Documentation** - JavaDoc completo
6. ‚úÖ **Testing** - Unit tests incluidos
7. ‚úÖ **Performance** - Lazy loading, caching
8. ‚úÖ **Security** - No permisos peligrosos

## üéì Referencias

- [Clean Architecture - Robert C. Martin](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Android Architecture Components](https://developer.android.com/topic/architecture)
- [SOLID Principles](https://en.wikipedia.org/wiki/SOLID)
- [Design Patterns](https://refactoring.guru/design-patterns)

---

Esta arquitectura garantiza:
- ‚úÖ Mantenibilidad a largo plazo
- ‚úÖ Testabilidad completa
- ‚úÖ Escalabilidad horizontal y vertical
- ‚úÖ Bajo acoplamiento, alta cohesi√≥n
- ‚úÖ F√°cil integraci√≥n en proyectos existentes
